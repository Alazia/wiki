{"pages":[{"title":"Categories","date":"2021-01-19T11:40:35.795Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2021-01-19T11:40:35.795Z","path":"tags/index.html","text":""},{"title":"About","date":"2021-01-19T11:40:35.795Z","path":"about/index.html","text":""}],"posts":[{"title":"About the wiki","date":"2021-01-19T09:08:16.000Z","path":"2021/01/19/index/","text":"关于本Wiki本Wiki由Alazia与DMSCC基于共享编程、游戏开发、设计等知识的目的，从自身项目、书籍、互联网等渠道整理归纳相关知识点、使用例，为今后的工作学习提供参考。声明:本Wiki部分内容来自互联网与数据，版权属于原作者，部分版权出处可能有遗漏，恳请各位朋友提出，感激不尽。","tags":[],"categories":[]},{"title":"Git","date":"2021-01-19T09:08:16.000Z","path":"2021/01/19/Git/","text":"为什么学Git? 1 工欲善其事，必先利其器 2 Def：distributed Version Control System(VCS) for tracking changes in computer files 3 His: &nbsp;&nbsp;&nbsp;Linus-&gt;Linux (1991)：diff+Linus手工合并代码:CVS\\SVN集中式速度慢,商用版不符合开源精神 &nbsp;&nbsp;&nbsp;2002：BitKeeper(BitMover)授权Linux社区免费使用 &nbsp;&nbsp;&nbsp;2005：Andrew(Samba开发者)试图破解BitKeeper协议，收回。 &nbsp;&nbsp;&nbsp;Linus-&gt;Git(by C) in two weeks &nbsp;&nbsp;&nbsp;2008:GitHub Install 1 win: https://git-scm.com/download/win Basic commands1234567$ git init &#x2F;&#x2F; initialize Local Git Repository $ git add&lt;file&gt; &#x2F;&#x2F; Add File(s) To Index$ git status &#x2F;&#x2F; Check Status of Working Tree$ git commit &#x2F;&#x2F; Commit Changes In Index$ git push &#x2F;&#x2F;Push to Remote Repository$ git pull &#x2F;&#x2F;Pull Latest From Remote Repository$ git clone &#x2F;&#x2F;clone Repository into a new Directory Use1.init 1 Def repository:一个可以被Git管理、追踪(Changes文件的修改、删除、添加)的仓库，以便将来可以“还原”。 2 Use: 1234$ mkdir myres &#x2F;&#x2F;创建文件目录$ cd myres &#x2F;&#x2F;进入文件夹$ git init &#x2F;&#x2F;初始化仓库(将文件夹转为Git仓库)Initialized empty Git repository in ..&#x2F;myres&#x2F;.git 2.add与commit 1 Def add: 将工作区文件添加到暂存区(Index/stage) commit: 提交添加(将文件从暂存区stage提交到版本库) rm: 删除文件 2 Use: 新建一个readme.md文件 12345$ git add readme.md &#x2F;&#x2F; 添加文件到暂存区stage，*表示all$ git commit -m &quot;add readme&quot; &#x2F;&#x2F; -m:message， 提交到res[master (root-commit) 99ae527] add readme1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 readme.md file changed 文件改动 insertions插入行数 deletions删除行数 3.status与diff 1 Def status: 查看仓库当前状态 diff: 比较修改内容[diff要在add之前使用] checkout - -与reset HEAD： 抛弃修改与撤销缓存(回到当前版本) 2 Use 修改readme.md，加入: Git is a distributed version control system 2.1.直接查看 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) readme被修改，但是还没有添加到暂存区准备提交。你可添加add到暂存区，同时也可以checkout -- 抛弃修改。 2.2.检查修改内容 12345678$ git diff readme.mddiff --git a&#x2F;readme.md b&#x2F;readme.mdindex e69de29..45e43ab 100644--- a&#x2F;readme.md+++ b&#x2F;readme.md@@ -0,0 +1 @@+Git is a distributed version control system\\ No newline at end of file 2.3.add并查看 1234567$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.md status表示 要被提交的修改有 readme.md，同时你也可以用reset HEAD 取消暂存。 2.4.commit并查看 123456$ git commit -m &quot;add distributed&quot;[master 51e675a] add distributed1 file changed, 1 insertion(+)$ git statusOn branch masternothing to commit, working tree clean status表示 没有需要提交的修改，工作目录是干净（working tree clean）的。 4.log、reset与reflog 1 Def: log: 显示从最近到最远的提交日志 reset: 重置(回退)版本 reflog: 显示命令日志 2 Use: 情景：三个版本 版本1：add distributed 1Git is a distributed version control system. 版本2：add free 12Git is a distributed version control system.Git is free softwave. 版本3：append GPL 12Git is a distributed version control system.Git is free softwave distributed under the GPL. 2.1.查看提交日志 123456789101112131415161718$ git logcommit 092719a05ea5929fb2a72c990ae3a38a5b0b8129 (HEAD -&gt; master)Author: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 17:54:32 2019 +0800 append GPLcommit 8a74499d95b927245debf21afadf001e621cb948Author: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 17:53:14 2019 +0800 add freecommit 51e675ad6e4a906bd4de3c65ef830b9564864ca4Author: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 17:39:11 2019 +0800 add distributed 通过log 我们可以看到3次提交，最近的一次是append GPL，上一次是add free，最早的一次是add distributed 简洁化查看提交日志 - -pretty=oneline 1234$ git log --pretty&#x3D;oneline092719a05ea5929fb2a72c990ae3a38a5b0b8129 (HEAD -&gt; master) append GPL8a74499d95b927245debf21afadf001e621cb948 add free51e675ad6e4a906bd4de3c65ef830b9564864ca4 add distributed 为了解决多人协作版本冲突问题，git采用了SHA1计算出的数字十六进制来表示版本号commit id 2.2.版本回退 HEAD 表示当前版本，HEAD^表示上一个版本，上N个版本用HEAD~N表示。 现在要从当前版本append GPL 回退到上一个版本 add free 123456$ git reset --hard HEAD^ &#x2F;&#x2F;使用commit id也可以HEAD is now at 8a74499 add free$ cat readme.mdGit is a distributed version control system.Git is free softwave 2.3.回到未来 当经过上一步版本回退后，查看提交日志时，你会发现新的版本已经消失： 123456789101112131415161718$ git logcommit 8a74499d95b927245debf21afadf001e621cb948 (HEAD -&gt; master)Author: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 17:53:14 2019 +0800 add freecommit 51e675ad6e4a906bd4de3c65ef830b9564864ca4Author: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 17:39:11 2019 +0800 add distributedcommit 99ae527b16c7a4fe17c77f383b4bdba54a5f5cebAuthor: alazia &lt;alazia@email.com&gt;Date: Sun Aug 4 16:56:38 2019 +0800 add readme 那么如何回到未来呢？ 我们可以通过git 查找到“未来”的版本号,并使用reset 回到未来。 12345678$ git reflog8a74499 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^092719a HEAD@&#123;1&#125;: commit: append GPL8a74499 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add free51e675a HEAD@&#123;3&#125;: commit: add distributed$ git reset --hard 092719aHEAD is now at 092719a append GPL remote1.SSH Key 1 创建SSH Key 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车使用默认值 通过查看电脑用户目录下.ssh目录,其中 id_rsa 为私钥，id_rsa.pub为公钥。 2 添加SSH Key 登录Github-&gt;Account Settings-&gt;SSH Keys-&gt;Add SSH Key 添加id_rsa.pub内容，Title任意。 Github SSH Key 的意义 因为GitHub需要识别出你的身份，才能允许你推送提交(Push)，而Git支持SSH协议，因此SSH Key是必要的。 2.本地到远程 1 添加远程库 情景：本地创建了仓库myres，需要在Github上建立远程仓库。 步骤一： Github创建同名仓库 步骤二： 在本地仓库下与Github仓库关联 1$ git remote add origin git@github.com:username&#x2F;resname.git &#x2F;&#x2F; origin 是git默认远程库叫法 Ps:这里需要将SSH KEY添加到账号/仓库中，否则只是关联，无法推送 步骤三： 推送本地仓库内容到远程库 12345678910$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15&#x2F;15), done.Writing objects: 100% (20&#x2F;20), 1.64 KiB | 560.00 KiB&#x2F;s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5&#x2F;5), done.To github.com:username&#x2F;resname.git* [new branch] master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;. Ps:第一次推送时,使用git push 实际上是把master 推送到了远程库，而加上-u参数不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 2 Push 推送 Def: 将本地master分支提交后的最新修改推送至GitHub Use: 1$ git push origin master 3.远程到本地 1 克隆远程库 情景：已经有了GitHub远程库，想要在本地建立仓库。 步骤一：获取远程库地址 步骤二：克隆远程库到本地 12345$ git clone git@github.com:username&#x2F;remotename.gitCloning into &#39;remotename&#39;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3&#x2F;3), done. 此时本地就有了远程仓库的所有文件 Ps: 远程库地址有两种： 1.git:// 默认使用ssh 2.https 但速度慢，并且每次推送需要输入口令 很多只开放http端口的公司只能使用https，而不使用ssh协议 2 Pull 拉取 Def: 将GitHub远程库当前版本拉取到本地 Use: 1$ git pull SSH警告 当第一次使用clone|push连接Github时，会得到一个警告： 123The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes&#x2F;no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts. Branch1.Def 分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。 为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。 2.创建与合并分支 1.Def： 在版本回退,我们知道,每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。 目前为止，只有一条主分支master，而HEAD是指向master,master才是指向提交的。 HEAD指向的就是当前分支. 2.branch 创建新的分支dev并切换 123$ git branch dev$ git checkout devSwitched to a new branch &#39;dev&#39; 或 12$ git checkout -b devSwitched to a new branch &#39;dev&#39; 此时，git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 修改提交后指针变化 在进入dev分支后，工作区的修改和提交就是针对dev分支了，比如此时新提交一次，则： 合并分支并删除dev 当dev上的工作完成后，将master直接指向dev当前提交时，便完成了合并 1234567$ git checkout master &#x2F;&#x2F;切回master,此时你会发现master里没有dev上更改的文件Switched to branch &#39;master&#39;$ git merge dev &#x2F;&#x2F;合并dev. Updating d46f35e..b17d20eFast-forwardreadme.txt | 1 +1 file changed, 1 insertion(+) Fast-forward表示这次合并时快进模式，也就是直接把master指向dev的当前提交，所以合并速度非常快。 123456$ git branch &#x2F;&#x2F;查看分支，*表示当前分支* devmaster$ git branch -d dev &#x2F;&#x2F;删除dev分支$ git branch * master 3.解决冲突 1 Def: conflict：冲突，同一处不同的修改合并产生的冲突。 2 Solution: 情景： feature1分支 提交修改了readme.md 1Creating a new branch is quick AND simple 1234$ git add *$ git commit -m &quot;AND&quot;[feature1 c5584de] AND1 file changed, 1 insertion(+), 2 deletions(-) master分支 提交修改了readme.md 1Creating a new branch is quick &amp; simple 1234$ git add *$ git commit -m &quot;&amp;&quot;[master 59d6553] &amp;1 file changed, 1 insertion(+), 2 deletions(-) merge命令 合并时： 1234$ git merge feature1Auto-merging readme.mdCONFLICT (content): Merge conflict in readme.mdAutomatic merge failed; fix conflicts and then commit the result. Git告诉我们readme.md发生了冲突，我们也可以通过status查看 123456789101112$ git statusOn branch masterYou have unmerged paths.(fix conflicts and run &quot;git commit&quot;)(use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:(use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: readme.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 我们打开readme.md 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new branch is quick AND simple&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 我们修改后保存再提交： 1Creating a new branch is quick AND simple 123$ git add readme.md$ git commit -m &quot;conflict fixed&quot;[master ec49478] conflict fixed 通过log查看分支合并情况： 123456789101112$ git log --graph --pretty&#x3D;oneline --abbrev-commit &#x2F;&#x2F;git log --graph命令可以看到分支合并图* ec49478 (HEAD -&gt; master) conflict fixed|\\| * c5584de (feature1) AND* | 59d6553 &amp;|&#x2F;* 092719a append GPL* 8a74499 add free“* 51e675a add distributed* 99ae527 add readme$ git branch -d feature1 &#x2F;&#x2F;最后删除分支Deleted branch feature1 (was c5584de). 4.分支管理策略 1 Def: 合并分支时，通常如果可能(不发生冲突),Git会默认使用Fast forward模式，但是这种模式下，删除分支后，会丢失分支信息。 如果要强制禁用Fast forward模式，Git会在merge时生成一个新的commit，这样就可以从分支历史上看出分支信息 即类似下面合并后： 2 Use:--no-ff 1234567891011$ git merge --no-ff -m &quot;merge with on-ff&quot; dev Merge made by the &#39;recursive&#39; strategy.readme.md | 2 +-1 file changed, 1 insertion(+), 1 deletion(-)$ git log --graph --pretty&#x3D;oneline --abbrev-commit* f0fcabe (HEAD -&gt; master) merge with no-ff|\\| * ee54c4c (dev) add merge|&#x2F;* ec49478 conflict fixed 3 实际开发 master分支仅用来发布新版本，是非常稳定的。 dev分支上进行开发，是不稳定的。 比如1.0版本发布时，先把dev分支合并到master上，再在master分支发布1.0版本； 而你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug与Feature分支 1 Bug分支 Def: 每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 情景： 你遇到一个代号404的bug，打算创建临时分支issue-404来修复，但dev上工作进行了一半还没提交。 步骤一：stash储存工作现场 12$ git stashSaved working directory and index state WIP on dev: f0fcabe merge with no-ff 步骤二： 从指定分支创建临时修复bug分支 1234$ git checkout masterSwitched to branch &#39;master&#39;$ git checkout -b issue-404Switched to a new branch &#39;issue-404&#39; 步骤三：修复bug 1234$ git add *$ git commit -m &quot;fix bug 404&quot;[issue-404 d9abeeb] fix bug 404 1 file changed, 1 insertion(+), 1 deletion(-) 步骤四：合并分支并删除bug分支 12345678910111213$ git checkout masterSwitched to branch &#39;master&#39;$ git merge --no-ff -m &quot;merged bug fix 404&quot; issue-404Merge made by the &#39;recursive&#39; strategy.readme.md | 2 +-1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-404Deleted branch issue-404 (was d9abeeb).$ git checkout devSwitched to branch &#39;dev&#39;$ git statusOn branch devnothing to commit, working tree clean 步骤五：stash apply+drop /pop恢复工作现场 1234567891011121314151617$ git stash liststash@&#123;0&#125;: WIP on dev: f0fcabe merge with no-ff$ git stash pop &#x2F;&#x2F;恢复同时删除stash内容，apply stash@&#123;0&#125;只是恢复，需要drop stash@&#123;0&#125;:删除On branch devChanges to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: hello.pyChanges not staged for commit:(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtDropped refs&#x2F;stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)$ git stash list &#x2F;&#x2F;检查 2 feature分支 Def: 在软件开发过程中，添加一个新功能时，肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支 情景一：开发完成，合并分支，删除分支，顺利完成。 情景二：功能叫停，含机密资料的分支必须销毁 123$ git branch -d feature-xerror: The branch &#39;feature-x&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D feature-x&#39;. 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。 12$ git branch -D feature-xDeleted branch feature-x (was 287773e). 多人协作与Rebase 1 Def： 在remote,我们学习了Push(推送)、PUll(拉取)，这里具体介绍多人协作时使用。 2 Remote远程库信息： 123$ git remote -vorigin git@github.com:username&#x2F;resname.git (fetch)origin git@github.com:username&#x2F;resname.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址 3 Push 推送分支 1$ git push origin branch-name master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步。 bug分支只用于在本地修复bug，就没必要推到远程了。 feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 4 Pull/Clone 抓取分支 多人协作时，大家都会往master和dev分支上推送各自的修改,但是从远程库clone时，默认只能看到本地的master 但是需要在dev进行开发，所以必须创建远程origin/dev分支关联： 1$ git checkout -b dev origin&#x2F;dev 在你修改提交dev后试图推送时，发现你的小伙伴已经推送了他的dev提交： 12345678$ git push origin devTo github.com:username&#x2F;resname.git! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &#39;git@github.com:username&#x2F;resname.git&#39;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 推送失败，这时候你需要将最新的提交拉取下来，在本地合并后解除冲突，再推送: 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; dev 拉取失败？这是因为没有指定本地dev分支与远程origin/dev分支的链接: 12$ git branch --set-upstream-to&#x3D;origin&#x2F;dev devBranch &#39;dev&#39; set up to track remote branch &#39;dev&#39; from &#39;origin&#39;. 链接完成后再进行相应操作：Pull-&gt;merge-&gt;fix conflict-&gt;Push 5 实际开发 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name送就能成功 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to branch-name origin/branch-name。 6 rebase Def: 多人在同一个分支上协作时,很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功,此时提交历史非常凌乱，为了解决这个问题，Git提供了Rebase変基。 Use: 在Push之前，通过rebase 进行提交历史的整理。rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 tag 1 Def: 发布一个版本时，我们通常先在版本库中打一个标签（tag），将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以标签也是版本库的一个快照。 2 Use: 123456789101112$ git tag name &#x2F;&#x2F;默认标签是打在最新提交的commit上的$ git tag name commit_id &#x2F;&#x2F;也可以先log查看commit,打在之前的版本上。$ git tag &#x2F;&#x2F;查看标签$ git show tagname &#x2F;&#x2F;查看具体的标签信息(提交id，作者，日期等)$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb$ git tag -d name &#x2F;&#x2F;删除$ git push origin tagname &#x2F;&#x2F;推送标签到远程$ git push origin --tags &#x2F;&#x2F;推送所有标签$ git tag -d v0.9 &#x2F;&#x2F;先删除本地标签$ git push origin :refs&#x2F;tags&#x2F;v0.9 从远程删除，也是push命令 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 其他Pull Request TODO Git 服务器搭建 TODO 参考资料： 1 Git &amp; GitHub Crash Course For Beginners 2 廖雪峰Git教程 3 猴子都能懂得GIT入门","tags":[],"categories":[{"name":"CODE","slug":"CODE","permalink":"http://example.com/categories/CODE/"},{"name":"Git","slug":"CODE/Git","permalink":"http://example.com/categories/CODE/Git/"}]}]}